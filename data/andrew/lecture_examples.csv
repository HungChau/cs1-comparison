2,"def cube_volume(side_length):  '''(number) -> number  >>> cube_volume(3)  27  >>> cube_volume(2)  8  '''  return side_length ** 3",cube.py,1
2,"3 + 82 * 82*162 ** 35 / 25 // 28 / 28 // 2type(1)type(1.0)type('1.0')a = 3b = 5a + bc = '3'd = '5'c + da = 4.5type(a)int(a)type(a)x = 37xprint(x)xy = x - 2xyx = 20xya = 5type(a)a = 5.0type(a)a = a + 3atype(a)a = a + 1aa = int(a)a",day2_shell_example.py,1
2,"print(4 + 5)4 + 5def f(x):  return x ** 2f(8)y = 4f(y)f(2 + 1)z = f(9)ztype(4.5)def add_one(x):  return x + 1add_one(4)x = 9x = x + add_one(x)xx = x + 1xqdef do_something(x):  q = 8  return qdo_something(4)do_something(5)do_somethig(15)do_something(20)q # no! q is local to do_somethingcube_volume(1)print(8 + 3)8 + 34print(4)def f(x):  return x ** 2f(3)f(1)f(-1)f(0)f(1.0)y = f(4)ytype(4.5)def add_one(x):  return x + 1add_one(4)add_one(0)add_one(3)x = 2x = x + add_one(x)xx = x + 1xcube_volume(2)add_one(2)piimport mathmath.piceilmath.ceil(4.5)math.ceil(4)math.ceil(2.1)xx = x + add_one(x)xdef plus_one(num):  return num + 1add_one(8)q = 10add_one(q)",day3_shell_example.py,1
2,"Truetype(True)False2 < 88 < 29 >= 99 > 94 != 44 == 4a = 3aa == 3a != 3b = (a != 3)bnot Falsenot Truea = Truenot anot (2 < 8)not not TrueTrue and FalseFalse and TrueFalse and FalseTrue and TrueFalse or FalseTrue or FalseTrue or True6 % 27 % 26 % 2 == 0",shell.day4.py,2
2,"def f():  return 9f()def first(a):  a = 8  return afirst(10)first(2)a = 20afirst(a)aa = 20first(a)def f(x):  return x + 2  return x + 3f(10)result = f(10)resultdef g(x):  print(x + 2)  print(x + 3)g(10)result = g(10)resultprint(result)a = print(10)print(a)def f4():  print(5)  return 5x = f4()xdef f5():  return 5  print(5)x = f5()xdef no_ret():  print(3)no_ret()x = no_ret()x",shell.day5.py,2
2,"def is_shorter(s1, s2):    '''(str, str) -> bool    Return True if the first string is shorter than the second; false otherwise.        >>> is_shorter("""", ""cat"")    True    >>> is_shorter(""kitten"", ""cat"")    False    >>> is_shorter(""cat"", ""dog"")    False    '''        return len(s1) < len(s2)    # After day 2: modify this so that it returns the shorter string",day1.is_shorter.py,3
2,"s = input(""Enter PH value: "")if len(s) > 0:    ph = float(s)    if ph < 7.0:        print(ph, 'is acidic.')    elif ph > 7.0:        print(ph, 'is basic.')    else:        print(ph, 'is neutral.')else:    print('No pH value was given!')",day2.ph.py,3
2,"# Given a server's response time:# return ""server down"" if there was no response (response time is none)# return ""server slow"" if the response takes longer than 5000 ms# return ""server okay"" if it returns a fast response_timedef server_status(response_time):    # Complete the docstring and code for this function!    if response_time == null:     return ""server down""    if response_time > 5000:     return ""server slow""    else:     return ""server okay""",day2.server_status.py,3
2,"def is_shorter(s1, s2):    '''(str, str) -> str    Return the shorter of the two provided strings.        >>> is_shorter("""", ""cat"")    ''    >>> is_shorter(""kitten"", ""cat"")    'cat'    >>> is_shorter(""cat"", ""dog"")    'dog'    '''        if len(s1) < len(s2):        return s1    else:        return s2",day2.shorter.py,3
2,"def can_vote(age):    """""" (int) -> bool    Return True iff age is legal voting age of at least 18 years.    >>> can_vote(16)    False    >>> can_vote(21)    True    """"""    # The following three blocks of code are equivalent, but the last is    # the best.    # Block 1: needless if statement    # if age < 18:    #     return False    # else:    #     return True    # Block 2: okay, but why not change the condition?    # return not (age < 18)    # Block 3: simplest condition    return age >= 18",day3.can_vote.py,3
2,"def is_positive(x):    '''(num) -> bool    Return True iff x >= 0    '''        # The following two blocks are equivalent, but the second is preferred.        # Block 1: redundant test    # return (x >= 0) == True        # Block 2: preferred -- simpler    return x >= 0",day3.is_positive.py,3
2,"# Original problem ...# Given a server's response time:# return ""server down"" if there was no response (response time is none)# return ""server slow"" if the response takes longer than 5000 ms# return ""server okay"" if it returns a fast response_time# We define a global value below, so that we can easily alter the value that# triggers the ""slow response"" message if a client/boss requests a change.SLOW_RESPONSE = 5000def server_status(response_time):    '''(int/None) -> str    Given a server's response time, return ""server down"" if there was     no response, ""server slow"" if the response took longer than 5000    ms, and ""sever okay"" otherwise.    >>> server_status(None)    'server down'    >>> server_status(0)    'server okay'    >>> server_status(4500)    'server okay'    >>> server_status(5000)    'server okay'    >>> server_status(5500)    'server slow'    '''    if response_time == None:        return ""server down""    elif response_time > SLOW_RESPONSE:        return ""server slow""    else:        return ""server okay""",day3.server_status.py,3
2,"def encrypt_letter(letter):    '''(str) -> str    Encrypt letter by shifting three places to the right.    Assume letter is lowercase.        >>> encrypt_letter('v')    'y'    '''    base = ord('a')    offset = ord(ch) - base + 3    if offset > 26:        offset = offset - 26    return chr(base + offset)#######################################################    # Here is an alternate solution that uses modulus:    # base = ord('a')    # return chr((ord(letter) + 3 - base) % 26 + base)def encrypt_word(word):    '''(str) -> str    Return the given word encrypted using encrypt_letter on each     alphabetic character in the word.    >>> encrypt_word('cat')    'fdw'    '''    # Here is some foreshadowing of what we will be working on over     # the next few weeks: loops!        new_word = """"       # an accumulator    for ch in word:        if ch.isalpha():            new_word += encrypt_letter(ch)        else:            new_word += ch  ",caesar_sol.py,4
2,"def bigger_char(s, ch):    '''(str, ch) -> bool    Return True iff no character in s is larger than the single character ch.    Assumption: all inputs are lowercase    >>> bigger_char('abc', 'a')    False    >>> bigger_char('abc', 'z')    True    '''        for char in s:        if char > ch:            return False    return True",bigger_char.py,4
2,"def count_spaces(s):    '''(str) -> int    Return the number of whitespace characters in s.    >>> count_spaces('hello world')    1    >>> count_spaces('nospaceshere')    0    >>> count_spaces('\t\t  \n')    5    '''    count = 0    for char in s:        if char.isspace():            count += 1    return count",count_spaces.py,4
2,"def contains_digit(s):    '''(str) -> bool    Return True iff s contains at least one numeral.        >>> contains_digit('123')    True    >>> contains_digit('aBcd?')    False    >>> contains_digit('a1')    True    >>> contains_digit('')    False    '''        for ch in s:        if ch.isdigit():            return True    return False",contains_digit.py,4
2,"def only_vowels(s):    '''(str) -> str    Return s with all non-vowel characters removed.    >>> only_vowels('abc')    'a'    >>> only_vowels('bcd')    ''    >>> only_vowels('aeiou')    'aeiou'    >>> only_vowels('ABC')    'A'    >>> only_vowels('')    ''    '''        vowel_s = ''    for char in s:        if char.lower() in 'aeiou':            vowel_s += char    return vowel_s",only_vowels.py,4
2,"def remove_spaces(s):   '''(str) -> str   Return s, but with all spaces removed.   >>> remove_spaces('abc!123')   'abc!123'   >>> remove_spaces('   \t\t\n\n')   ''   >>> remove_spaces('')   ''   '''      nospace_s = ''   for char in s:       if not char.isspace():           nospace_s += char   return nospace_s",remove_spaces.py,4
2,"def get_valid_password():    '''() -> str    Return a valid user-entered password. A password is valid if it includes at    least one capital letter, one lowercase letter, and one non-letter character.    '''    valid = False    while not valid:        password = input(""Enter a valid password: "")        valid = password.lower() != password and \                password.upper() != password and \                not password.isalpha()    return password    # Alternate implementation    # Idiom for ""do-while""    while 1:        password = input(""Enter a valid password: "")        if password.lower() != password and \           password.upper() != password and \           not password.isalpha():            break    return password",day1.get_valid_password.py,5
2,"import randomdef guess():    '''() -> None    Engage the user in a guessing game. Repeatedly ask the user to select    a number between 1 and 10, until they guess the correct (randomly     selected) number.    '''    answer = random.randint(1, 10)    guess = input(""Guess a number between 1 and 10: "")    while int(guess) != answer:        guess = input(""Sorry, guess again: "")    print(""Got it!"")",day1.guessing_game.py,5
2,"def index_of(s, ch, n):    '''(str, str, int) -> int    Return the index of the nth instance of character ch in the string s or    -1 if there is no nth instance of ch in s.    >>> index_of('abcaca', 'a', 1)    0    >>> index_of('abcaca', 'a', 2)    3    >>> index_of('abcaca', 'a', 4)    -1    '''    index = 0    count = 0    while index < len(s) and count < n:        if s[index] == ch:            count += 1        index += 1    if count == n:        return index - 1    return -1",day1.index_of.py,5
2,"def all_titlecase(L):    '''(list of strings) -> bool    Return True iff all of the strings in L are titlecased.    >>> all_titlecase([])    True    >>> all_titlecase(['The Book of Three', 'The Name of the Wind', 'Snow Crash'])    True    >>> all_titlecase(['The Book of Three', 'The Name of the Wind', 'SNow Crash'])    False    '''    for title in L:        if title.title() != title:            return False    return True",day2.all_titlecase.py,5
2,"def get_even(L):    '''(list of int) -> list of int    Return a list containing the even elements of L.    >>> get_even([])    []    >>> get_even([1, 3])    []    >>> get_even([2, 1, 2])    [2, 2]    '''    evens = []    for item in L:        if item % 2 == 0:            evens.append(item)    return evens",day2.get_even.py,5
2,"def double_items(L):    '''(list) -> None    Double all of the values in the list of numeric values L.    >>> L = [1, 2, 3]    >>> double_items(L)    >>> L    [2, 4, 6]    >>> L = []    >>> double_items(L)    >>> L    []    '''    for index in range(len(L)):        L[index] = L[index] * 2",day3.double_items.py,5
2,"def every_third(s, n):    '''(str) -> str    Return a string composed of every third character from s, starting from index n.    >>> every_third('abcd', 0)    'ad'    >>> every_third('abcd', 1)    'b'    >>> every_third('abcd', 4)    ''    '''    result = ''    for index in range(n, len(s), 3):        result += s[index]    return result",day3.every_third.py,5
2,"def is_valid_password(password):    '''(str) -> bool    Return True iff password contains a non-letter character and contains both upper and     lowercase letters.    >>> is_valid_password('aA3bc')    True    >>> is_valid_password('aa3bc')    False    >>> is_valid_password('AA3BC')    False    >>> is_valid_password('AAbBC')    False    '''        return not password.isalpha() and \           password.lower() != password and \           password.upper() != passworddef remove_invalid(password_list):    '''(list of str) -> None    Remove invalid passwords from password_list.        >>> L = ['aA3', 'aA3bc', 'aa3bc', 'AA3BC', 'AAbBC']    >>> remove_invalid(L)    >>> L    ['aA3', 'aA3bc']    '''    # Easier with a while loop ...    index = 0    while index < len(password_list):        if is_valid_password(password_list[index]):            index += 1        else:            password_list.pop(index)    def filter_invalid(password_list):    '''(list of str) -> list of str    Return a list that contains the valid passwords from password_list.    >>> L = ['aA3', 'aA3bc', 'aa3bc', 'AA3BC', 'AAbBC']    >>> remove_invalid(L)    ['aA3', 'aA3bc']    >>> L    ['aA3', 'aA3bc', 'aa3bc', 'AA3BC', 'AAbBC']    '''    filtered = []    for password in password_list:        if is_valid_password(password):            filtered.append(password)    return filtered",day3.remove_invalid.py,5
2,"def col_sums(lst):    '''(list of list of int) -> list of int    Return a new list that contains the sum of each column in lst.     All columns in lst are of the same length.    >>> col_sums([[5, 10, 15], [1, 2, 3]])    [6, 12, 18]    '''    ans = []    for column in range(len(lst[0])):        total = 0        for row in range(len(lst)):            total = total + lst[row][column]        ans.append(total)    return ans",day1.column_sums.py,6
2,"def is_ok(group_list, class_list):    '''list of list of int, list of int) -> bool    Return True iff every student in class_list is in exactly one group     according to group_list.    >>> ...    '''    for student in class_list:        num_groups = 0        for group in group_list:            if student in group:                num_groups = num_groups + 1        if num_groups != 1:            return False    return True",day1.is_ok.py,6
2,"def count_instances(group_list, item):    '''(list of list of int) -> int    Return the number of instances of item in group_list.    >>> count_instances([[1, 2], [2, 3]], 2)    2    >>> count_instances([[1, 2], [2, 3]], 3)    1    >>> count_instances([[1, 2], [2, 3]], 4)    0    '''    count = 0    for group in group_list:        # This works fine, but let's also look at a loop:        # count += group.count(item)        for el in group:            if el == item:                count += 1    return count",day2.count_instances.py,6
2,"def find(lst, value):    '''(list, value) -> int    Return the index of the first occurrence of value in lst.    If value is not found, return -1.      >>> find([20, 40, 60], 40)    1    '''    for i in range(lst):        if lst[i] == value:            return i    return -1    # let's try while-loop    i = 0    while i < len(lst):        if lst[i] == value:            return i        i = i + 1    return -1",day2.find.py,6
2,"def no_extra_members(group_list, class_list):    '''(list of list of int, list of int) -> bool    Return True iff every student in group_list is a    member of class_list.    >>> no_extra_members([[1, 3, 4], [2]], [1, 2, 3, 4])    True    >>> no_extra_members([[1, 2], [3, 4]], [1, 2, 4])    False    '''    # Here is a variant of a ""check property"" pattern.    # In this pattern, we check every item in the list    # (or nested list, in this case) for a property. If    # any item does not have that property, then we    # return False. If all items have the desired property,    # then we return True *after* the loop.    for group in group_list:        for student in group:            if student not in class_list:                 return False    return True",day2.no_extra_members.py,6
2,"def longest_sequence(f):    '''(file) -> int    Return the number of lines in the longest    consecutive sequence of blank lines in f,    or zero if there are no blank lines at all.    '''    longest = 0    current = 0    for line in f:        if line == '\n':            current += 1            if current > longest:                longest = current        else:            current = 0    return longest",day3.longest_sequence.py,6
2,"# This file works with a text file containing data about# band preferences. For example:# Band,Rating,Plays# The Black Keys,8,193def get_bandnames(band_file):    '''(file) -> list of str    Return a list of all of the bandnames in a band file.    Assumption: Header lines have been removed    '''    bands = []    for line in band_file:        fields = line.strip().split("","")        bands.append(fields[0])    return bandsdef average_rating(band_file):    '''(file) -> float    Return the average rating for all bands in band_file.    Assumption: Header lines have been removed.    '''    sum = 0    count = 0    for line in band_file:        fields = line.strip().split("","")        sum += int(fields[1])        count += 1    return sum / count    # The following also works fine. It uses a list instead    # of a pair of accumulators.    # ratings = []    # for line in band_file:    #     fields = line.strip().split("","")    #     ratings.append(int(fields[1]))    # return sum(ratings) / len(ratings)",parse_bands.py,6
2,"def count_chars(s):    '''(str) -> list of (str, int) tuples    Return a list that contains character counts from the str s.     >>> count_chars('')    []    >>> count_chars('aaa')    [('a', 3)]    >>> count_chars('baaab')    [('a', 3), ('b', 2)]    '''    counts = []    for ch in s:        ch_count = s.count(ch)        if (ch, ch_count) not in counts:            counts.append((ch, ch_count))    return sorted(counts)",day1.count_chars.py,7
2,"def index_chars(s):    '''(str) -> list of (str, list of int) tuples    Return a list that contains the indices of characters in the str s.    >>> index_chars('')    []    >>> index_chars('aaa')    [('a', [0, 1, 2])]    >>> count_chars('baaab')    [('a', [1, 2, 3]), ('b', [0, 4])]    '''    chars = []    for ch in s:        if ch not in chars:            chars.append(ch)    indices = []    for ch in sorted(chars):        indices.append((ch, []))        for index in range(len(s)):            if s[index] == ch:                indices[-1][1].append(index)    return indicesdef gen_string(ch_indices):    '''(list of (str, list of int) tuples) -> str    Return the str specified by the list of character indices.    >>> gen_string([])    ''    >>> gen_string([('a', [0, 1, 2])])    'aaa'    >>> gen_string([('a', [1, 2, 3]), ('b', [0, 4])])    'baaab'    '''    chars = []    for (ch, indices) in ch_indices:        for index in indices:            chars.extend([''] * (index - len(chars) + 1))            chars[index] = ch    return ''.join(chars)",day1.index_chars.py,7
2,"def count_albums(albums):    '''(file) -> dict    Return a dictionary that contains mappings between     the artists in the file albums and the number of     albums they have authored.    '''        albums.readline()            album_dict = {}    for line in albums:        fields = line.strip().split("","")        artist = fields[0]        album_dict[artist] = album_dict.get(artist, 0) + 1            return album_dict",day2.parse_albums.py,7
2,"def add_sighting(kinds, counts, sighting):    '''(list of str, list of int, str) -> NoneType    Update the list of types of items seen and the list    of times each item has been seen.    >>> animals = ['cat', 'dog']    >>> counts = [1, 2]    >>> add_sighting(animals, counts, 'goose')    >>> animals    ['cat', 'dog', 'goose']    >>> counts    [1, 2, 1]    >>> add_sighting(animals, counts, 'dog')    >>> animals    ['cat', 'dog', 'goose']    >>> counts    [1, 3, 1]    '''    if sighting in kinds:        index = kinds.index(sighting)        counts[index] += 1    else:                  # Not in the list        kinds.append(sighting)        counts.append(1)def add_sighting_v2(sightings, new_sighting):    '''(dict, str) -> None    Update the dictionary of sightings with the new_sighting.    '''    sightings[new_sighting] = sightings.get(new_sighting, 0) + 1",day2.sightings.py,7
2,"def combine(d1, d2):    '''(dict of {v:list of int}, dict of {w:list of int}) ->       dict of {x:int}    Return the dictionary where each key is a key    that is in both d1 and d2.    The value associated with each key in the new    dictionary is the sum of all the integers associated    with that key in d1 and d2.    >>> combine({1:[2], 4:[5, 6]}, {4:[8]})    {4:19}    '''    combined = {}    for key in d1:        if key in d2:            combined[key] = sum(d1[key]) + sum(d2[key])    return combined",day3.combine.py,7
2,"def fold(d1, d2):    '''(dict, dict) -> dict    Return a new dictionary that contains all (b, c)    such that (a, b) is in d1 and (a, c) is in d2.    >>> fold({1:4, 9:10}, {1:5})    {4:5}    '''    folded = {}    for key in d1:        if key in d2:            folded[d1[key]] = d2[key]    return folded",day3.fold.py,7
2,"def invert(d):    '''(dict) -> dict    Return the inverted version of d.      >>> returned = invert({1: 10, 2: 10})    >>> returned == {10: [1, 2]} or returned == {10: [2, 1]}    True    '''    inv = {}    for (k, v) in d.items():        inv.setdefault(k, []).append(v)    return inv    # Alternate form    inv = {}    for (k, v) in d.items():        if v in inv:            inv[v].append(k)        else:            inv[v] = [k]    return inv",day3.invert.py,7
2,"def increment_count(d, k):     '''(dict of (object: int), object) -> None    Increment the associated with k in d. If k is not a key in d, add k with value 1.    k is immutable.    '''    d[k] = d.get(k, 0) + 1if __name__ == '__main__':    import doctest    doctest.testmod()",day2.increment_count.py,8
2,"def indices(s, substr):     '''(str, str) -> list of int     Return the indices in s at which non-overlapping     copies of substr start. substr is non-empty.    >>> indices('A Coool pool look', 'oo')     [3, 9, 14]     '''    index = 0    indices = []    while index != -1:        indices.append(big.find(small, index))        index = big.find(small, index + len(small))    return indicesif __name__ == '__main__':    import doctest    doctest.testmod()",day2.indices.py,8
2,"def insert_after(L, item1, item2):     '''(list, object, object) -> None    Insert item2 after each occurrence of item1 in list L.    '''    index = 0    while index < len(L):        if L[index] == item1:            L.insert(index + 1, item2)            index += 1        index += 1    # Bad version ... run at your peril when item1 == item2    # for item in L:    #     if item == item1:    #         L.insert(L.index(item) + 1, item2)if __name__ == '__main__':    import doctest    doctest.testmod()",day2.insert_after.py,8
2,"def ourmax(num1, num2):    '''(number, number) -> number    Return the larger of num1 and num2.    '''    if num1 > num2:        return num1    else:        return num2if __name__ == '__main__':    import doctest    doctest.testmod()",day2.max.py,8
2,"def to_dict(lst):    '''(list of object) -> dict    Return a dict whose key/value pairs are the pairs    of elements in lst. lst has even length.      >>> r = to_dict([3, 4, 1, 2])    >>> r == {3: 4, 1: 2}    True    '''    d = {}    for i in range(0, len(lst), 2):        d[lst[i]] = lst[i + 1]    return ddef make_all_values_equal(d, v):    '''(dict, object) -> NoneType    Modify d so that each of its values equals v.    '''    for key in d:        d[key] = vif __name__ == '__main__':    import doctest    doctest.testmod()",day3.dict.py,8
2,"def average_grade(grade_list):    '''(list of list of [str, int]) -> float    Return the average grade for all the students in grade_list where the inner    lists contain a student ID and a grade.    >>> average_grade([['998765', 70], ['111234', 90], ['444567', 83]])    81.0    '''    total = 0    for item in grade_list:                total += item[1]    return total / len(grade_list)def student_ids(grade_list):    ''' (list of list of [str, int]) -> list of str    Return the student IDs for all the students in grade_list where the inner    lists contain a student ID and a grade.        >>> student_ids([['998765', 70], ['111234', 90], ['444567', 83]])    ['998765', '111234', '444567']    '''    id_list = []    for student in grade_list:        id_list.append(student[0])    return id_listif __name__ == ""__main__"":    import doctest    doctest.testmod()",day3.nested_list_examples.py,8
2,"def abs(n):    '''(number) -> number    Return absolute value of n.    >>> abs(8)    8    '''    # try breaking this code and running doctest    # to see the example in the docstring fail    if n < 0:        n = -n    return nif __name__ == '__main__':    import doctest    doctest.testmod()",day3.numbers.py,8
2,"def choose_chars(s1, s2, mask):    '''(str, str, str) -> str    Return a string where index i is s1[i] if mask[i] is 0 and s2[i] if mask[i] is 1.    Note: s1, s2, and mask are all of the same length.    Note: mask consists only of characters 0 and 1.    '''    sout = ''    for index in range(len(mask)):        if mask[index] == '0':            sout += s1[index]        else:            sout += s2[index]    return soutif __name__ == '__main__':    import doctest    doctest.testmod()",day3.strings.py,8
2,"def count_occurrences(L):    '''(list of v) -> dict of {v:int}    Return a dictionary in which the keys are    the items in L and their associated values    are integers denoting the number of times the item is    contained in L.    >>> count_occurrences([8, 9, 8, 8, 9])    {8: 3, 9: 2}    '''    d = {}    for element in L:        d[element] = d.get(element, 0) + 1    return d",day1.occurrences.py,9
2,"import randomdef associate_pair(d, key, value):    '''(dict of {object: list}, object, object) -> NoneType    key is immutable. Add the key-value pair to d.    If key occurs in d, append value to its    list of values. Otherwise, insert this new key and make its value be a    list of one element: [value].    '''    if key in d:        d[key].append(value)    else:        d[key] = [value]    # Alternately:    # d.setdefault(key, []).append(value)def make_dictionary(f):    '''(file) -> dict of {str: list of str}    Return a dictionary where the keys are words in f and the value    for a key is the list of words that were found to follow the key in f.    '''    d = {}    context = ''    for line in f:        word_list = line.split()        for word in word_list:            # We have a word and its context.  Remember that in the dictionary            associate_pair(d, context, word)            # The current word becomes the context for the next word.            context = word    return ddef mimic_text(word_dict, num_words):    '''(dict of {str: list of str}, int) -> str    Based on the word patterns in word_dict, return a string that mimics    that text, and has num_words words.    '''    story = ''    context = ''    for i in range(num_words):        # Choose the next word, based on context        follow_words = word_dict[context]        word = follow_words[random.randint(0, len(follow_words) - 1)]        story = story + ' ' + word # add to story        context = word    return storyif __name__ == '__main__':    # Read a text and remember the words and what comes after them in a dict    f = open(input(""Training text: ""))    d = make_dictionary(f)    f.close()    print(mimic_text(d, 100))",ll1.py,9
2,"import randomdef associate_pair(d, key, value):    '''(dict of {object: list}, object, object) -> NoneType    key is immutable. Add the key-value pair to d.    If key occurs in d, append value to its    list of values. Otherwise, insert this new key and make its value be a    list of one element: [value].    '''    if key in d:        d[key].append(value)    else:        d[key] = [value]    # Alternately:    # d.setdefault(key, []).append(value)def random_element(lst):    '''(list of object) -> object    Return a random element of nonempty lst.    '''    return lst[random.randint(0, len(lst) - 1)]def make_dictionary(f, context_length):    '''(file, int) -> dict of {tuple of str:list of str}    Return a dictionary where the keys are tuples of length context_length    containing words in f and the value for a key is the list of words    that were found to follow the key in f.    '''    d = {}    context = ('',) * context_length    for line in f:        word_list = line.split()        for word in word_list:            # We have a word and its context.  Remember that in the dictionary            associate_pair(d, context, word)            # Roll the context forward.            context = context[1:] + (word,)    return ddef mimic_text(word_dict, num_words, context_length):    '''(dict of {tuple of str:list of str}, int, int) -> str    Based on the word patterns in word_dict, return a string that mimics    that text, and has num_words words. context_length    is the length of the tuples in word_dict.    '''    story = ''    context = random_element(list(word_dict.keys()))    for i in range(num_words):        # Choose the next word, based on context        if context not in d: # start at new context            context = random_element(list(word_dict.keys()))        word = random_element(word_dict[context])        story = story + ' ' + word # add to story        context = context[1:] + (word,)    return storyif __name__ == '__main__':    # Read a text and remember the words and what comes after them in a dict    f = open(input(""Training text: ""))    d = make_dictionary(f)    f.close()    print(mimic_text(d, 100))",ll2.py,9
2,"def linear(L):    index = 0    while index < len(L):        index = index + 1        def quadratic(L):    index = 0                   # 1    while index < len(L):       # n        index2 = 0              # n        while index2 < len(L):  # n * n            index2 += 1         # n * n        index +=1               # n                                # 2n**2 + 3n + 1 => O(n**2)                    def cubic(L):    index = 0    while index < len(L):        index2 = 0        while index2 < len(L):            index3 = 0            while index3 < len(L):                index3 += 1            index2 += 1        index +=1                def log(L):    index = 0    while 2 ** index < len(L):        index += 1        def exp(L):    index = 0    while index < 2 ** len(L):        index += 1        def constant(L):    index = 0    while index < 1000000:        index += 1",complexities.py,10
2,"# Linear search checks every item in the list in turn. It stops when the# item is found or when no more items are contained in the list.def linear_search_v1(L, item):    '''Return the index of item in list L. If item is not in L, return -1.    '''    index = 0    while index < len(L) and L[index] != item:        index += 1    if index == len(L):        index = -1    return index#  Version 1 works, but we didn't like how we had to set the index# to -1 at the end. We decided we would start at the end and search# toward the beginning instead. The complexity of the code is the# same, but the implementation is cleaner.def linear_search_v2(L, item):    '''Return the index of item in list L. If item is not in L, return -1.    '''    # The not found case should return -1, so search the list backwards.    index = len(L) - 1    while index >= 0 and L[index] != item:        index -= 1    return indexdef time_searchfunc(f, sz):    '''Return the time required to search a list of size sz using the    search function f. Always performs a worst-case search.    '''    import random    import time    large_L = range(sz)    random.shuffle(large_L)    t1 = time.time()    index = f(large_L, -1)    t2 = time.time()    return t2 - t1# For comparison, let's see how fast Python's search is.def python_search(L, item):    return L.index(item)if __name__ == ""__main__"":    for sz in range(10000, 160001, 10000):        print        ""%d items: %f"" % (sz, time_searchfunc(linear_search_v2, sz))    # Python's search is comparable to linear search!    print    ""Python search on %d items: %f"" % (sz, time_searchfunc(python_search, sz))",searching.py,10
2,"def bubble_sort(L):    '''(list) -> None        Sort the items in L in non-descending order.    '''        for iteration in range(len(L)):        for index in range(len(L) - 1 - iteration):            print(L)            if L[index] > L[index + 1]:                L[index], L[index + 1] = L[index + 1], L[index]    print(L)# =========================================================        # The core of the insertion_sort algorithm is the ""insert"" operation. This function# inserts the next item in the ""unsorted"" part of the list into the correct place# in the sorted section of the list.def insert(L, index):    '''(list, int) -> None        Insert the item at position index in list L into the range [0..index] so    that [0..index] is in sorted order. [0..index-1] is already sorted.    '''        while index > 0 and L[index - 1] > L[index]:        L[index], L[index - 1] = L[index - 1], L[index]        index -= 1def insertion_sort(L):    '''(list) -> None        Sort the items in L in non-descending order.    '''        print(L)    for index in range(len(L)):        insert(L, index)        print(L)        # =========================================================  # The core of the selection sort algorithm is the ""find minimum"" operation. This# finds the next item to be placed into the sorted section of the list.def find_min(L, index):    '''(list, int) -> int        Return the index of the smallest number in list L that is at or after    position index.    '''    # Useful trick: When you need to find the smallest (or largest) item in a list,    # set the initial value to the first item in the list.    smallest_index = index    for i in range(index, len(L)):        if L[smallest_index] > L[i]:            smallest_index = i    return smallest_index                def selection_sort(L):    '''(list) -> None        Sort the items in L in non-descending order.    '''       print(L)     for index in range(len(L)):        swap_index = find_min(L, index)        L[index], L[swap_index] = L[swap_index], L[index]        print(L)# ========================================================def mergesort(L):    '''(list) -> list        Return a list that contains the items in L in non-descending order.    '''        # Recursive algorithm: base case.     if len(L) < 2:        return L    # Recursive case. Note how the problem gets smaller (sorting a smaller     # list) on each call.      midpt = len(L) // 2    L1 = mergesort(L[: midpt])    L2 = mergesort(L[midpt: ])    merged = merge(L1, L2)    return mergeddef merge(L1, L2):    '''(list, list) -> list        Return a new list that contains the items in L1 and L2 in     non-descending order. L1 and L2 are both already in that order.    '''        merged = []    index1, index2 = 0, 0    # merge the two lists until one is empty    while index1 < len(L1) and index2 < len(L2):        if L1[index1] < L2[index2]:            merged.append(L1[index1])            index1 += 1        else:            merged.append(L2[index2])            index2 += 1    # If a list is empty, it doesn't change the accumulated list if we add it.        merged += L1[index1:]    merged += L2[index2:]    return merged# ======================================================== def system_sort(L):    '''(list) -> None        Sort the items in L in non-descending order.    '''    L.sort()        if __name__ == ""__main__"":    from timing import time_listfunc    bubble_sort([7, 4, -1, 9, 3, 6, 42])    #for sz in range(1000, 8001, 1000):    #    print(""Bubble Sort on %d items: %f"" % (sz, time_listfunc(bubble_sort, sz, 1)))    #    print(""Selection Sort on %d items: %f"" % (sz, time_listfunc(selection_sort, sz, 3)))    #    print(""Insertion Sort on %d items: %f"" % (sz, time_listfunc(insertion_sort, sz, 3)))    #    print(""Merge Sort on %d items: %f"" % (sz, time_listfunc(mergesort, sz, 3)))    #    print(""System Sort on %d items: %f"" % (sz, time_listfunc(system_sort, sz, 3)))",sorts.py,10
2,"def make_list(n): '''(int) -> list of int  Return a random list of n ints. '''  import random res = list(range(n)) random.shuffle(res) return resdef time_listfunc(f, n, m): '''(func, int, int) -> float  Return how many seconds it takes to run function f on a shuffled  list with n items, on average over m times. ''' import time total = 0 for i in range(m):  L = make_list(n)  t1 = time.time()  L = f(L)  t2 = time.time()  total += t2 - t1 return total / m",timing.py,10
2,"## # This module defines the Counter class. # class Counter:  '''Tally counters that can be incremented, viewed, or reset.'''  def get_value(self):    '''() -> int      Return current value of this Counter.    '''    return self._value   def click(self):    '''() -> NoneType    Advances the value of this Counter by 1.    '''    self._value = self._value + 1   def reset(self):    '''() -> NoneType    Reset the value of this Counter to 0.    '''    self._value = 0 ",day1.counter.py,11
2,"class Point:  '''Two-dimensional points'''  def __init__(self):    '''() -> Point    Create two-dimensional point    '''    self.x = 0    self.y = 0",day1.point1.py,11
2,"class Point:  '''Two-dimensional points'''  def __init__(self, x, y):    '''(int, int) -> Point    Create two-dimensional Point at (x, y)    '''    self.x = x    self.y = y",day1.point2.py,11
2,"class Account:  def __init__(self):    '''() -> Account        Create bank account with 0 gold.    '''    self.gold = 0      def add_gold(self, amount):    '''(int) -> NoneType        Add amount gold to Account.    '''    self.gold += amount          def zero_gold(self):    '''() -> NoneType        Make the Account have 0 gold.    '''    self.gold = 0      def double_gold(self):    '''() -> NoneType        Double the gold in the Account.    '''    self.gold *= 2    ",day2.account.py,11
2,"import mathclass Point:  '''Two-dimensional points'''  def __init__ (self, x, y):    '''(int, int) -> Point    Create two-dimensional Point at (x, y)    '''    self.x = x    self.y = y  def __str__(self):    '''() -> str    Return string form of Point.    '''    return '({0}, {1})'.format(self.x, self.y)  def translate(self, dx, dy):    '''(int, int) -> NoneType    Move Point dx horizontally and dy vertically.    '''    self.x += dx    self.y += dy  def distance(self, other):    '''(Point) -> float    Return distance between this Point and other.    '''    a = (other.x - self.x) ** 2    b = (other.y - self.y) ** 2    return math.sqrt(a + b)class Segment:  def __init__(self, p1, p2):    '''(Point, Point) -> Segment    '''    self.p1 = p1    self.p2 = p2  def translate(self, dx, dy):    '''(int, int) -> NoneType    Move Segment by dx horizontally and dy vertically.    '''    self.p1.translate(dx, dy)    self.p2.translate(dx, dy)  def length(self):    '''() -> float    Return length of Segment.    '''    return self.p1.distance(self.p2)",day2.point3.py,11
2,"class Point(object):    def __init__(self, x=0, y=0):        self.x = x        self.y = y    # Conversions    def __str__(self):        return ""({0}, {1})"".format(self.x, self.y)    def __repr__(self):        return ""Point({0}, {1})"".format(repr(self.x), repr(self.y))            # Equality operators    # __lt__, __gt__, __le__, __ge__, __eq__, __ne__    def __eq__(self, rhs):        return (self.x ** 2 + self.y ** 2) == (rhs.x ** 2 + rhs.y ** 2)    def __lt__(self, rhs):        return (self.x ** 2 + self.y ** 2) < (rhs.x ** 2 + rhs.y ** 2)    def __le__(self, rhs):        return self < rhs or self == rhs    def __gt__(self, rhs):        return not (self <= rhs)    def __ge__(self, rhs):        return not (self < rhs)    def __ne__(self, rhs):        return not (self == rhs)                    ",day3.point4.py,11
2,"import functools @functools.total_orderingclass Point(object):    def __init__(self, x=0, y=0):        self.x = x        self.y = y    # Conversions    def __str__(self):        return ""({0}, {1})"".format(self.x, self.y)    def __repr__(self):        return ""Point({0}, {1})"".format(repr(self.x), repr(self.y))    # Arithmetic operators    def __sub__(self, rhs):        # Here's an error checking example: we want subtraction to only        # be defined between two points.        if type(rhs) is not Point:            raise TypeError(""unsupported operand type(s) for -: "" +                   ""'Point' and '{0}'"".format(type(rhs).__name__))        return Point(self.x - rhs.x, self.y - rhs.y)            # Equality operators    # functools.total_ordering gets us the other operators once we have    # defined __eq__ and one other    def __eq__(self, rhs):        return (self.x ** 2 + self.y ** 2) == (rhs.x ** 2 + rhs.y ** 2)    def __lt__(self, rhs):        return (self.x ** 2 + self.y ** 2) < (rhs.x ** 2 + rhs.y ** 2)",day3.point5.py,11
2,"class C(object):    def __init__(self):        self._x = None    @property    def x(self):        """"""I'm the 'x' property.""""""        print(""getter"")        return self._x    @x.setter    def x(self, value):        print(""setter"")        self._x = value    @x.deleter    def x(self):        del self._x",day2.properties.py,12
2,"class BankAccount(object):    interest_rate = .03             # A class attribute        # Constructor with default parameter    def __init__(self, owner, balance=0):        self.owner = owner        self._balance = balance     # A ""private"" member            def withdraw(self, amt):        '''(int) -> bool        Return True iff there are sufficient funds to cover the         withdrawal. If there are enough funds, deduct from balance.        '''        if self._balance >= amt:            self._balance -= amt            return True        return False        def deposit(self, amt):        '''(int) -> int        Return the new balance after depositing amt.        '''        self._balance += amt        return self._balance    @property    def balance(self):        '''() -> int        Return the account's balance.        '''        return self._balance            # With the two functions below, this no longer functions like a bank    # account. Do you want someone to be able to delete their balance?    # Or modify it directly?  We would not normally provide these. If we     # didn't, it wouldn't be possible for someone to directly manipulate     # the balance variable.    @balance.setter    def balance(self, value):        self._balance = value            @balance.deleter    def balance(self):        self._balance = 0    # Remember: attributes and methods that start with __ are used by the    # system. In this case, __str__ is invoked whenever you use str(...)    def __str__(self):        '''() -> str        Return a str representation of the object.        '''        return ""%s's bankaccount (%d)"" % (self.owner, self._balance)        ",day2.getters.py,12
2,"# From Lambert, Fundamentals of Python: From First Programs through Data Structuresfrom bank import SavingsAccountclass RestrictedSavingsAccount(SavingsAccount):    '''Restricted savings accounts.'''    MAX_WITHDRAWALS = 3            def __init__(self, name, pin, balance = 0.0):        '''(str, str, int) -> RestrictedSavingsAccount        Create RestrictedSavingsAccount with given name, pin, and balance.        '''        SavingsAccount.__init__(self, name, pin, balance)        self._counter = 0    def withdraw(self, amount):        '''(int) -> str or NoneType        Withdraw the given amount. Return None if successful,        or an error message if unsuccessful.        '''        if self._counter == \           RestrictedSavingsAccount.MAX_WITHDRAWALS:            return 'No more withdrawals this month'        else:            message = SavingsAccount.withdraw(self, amount)            if message == None:                self._counter += 1            return message    def reset_counter(self):        '''() -> NoneType        Reset the number of withdrawals.        '''        self._counter = 0",day1.restricted_savings.py,12
2,"# From Lambert, Fundamentals of Python: From First Programs through Data Structuresclass SavingsAccount:    '''Savings accounts with owner's name, PIN, and balance.'''        RATE = 0.02            def __init__(self, name, pin, balance = 0.0):        '''(str, str, int) -> SavingsAccount        Create SavingsAccount with given name, pin, and balance.        '''        self._name = name        self._pin = pin        self._balance = balance    def __str__(self):        '''() -> str        Return string representation of SavingsAccount.        '''        result =  'Name:    ' + self._name + '\n'         result += 'PIN:     ' + self._pin + '\n'         result += 'Balance: ' + str(self._balance)        return result    def get_balance(self):        '''() -> int        Return balance of this SavingsAccount.        '''        return self._balance    def get_name(self):        '''() -> str        Return name of this SavingsAccount.        '''        return self._name    def get_pin(self):        '''() -> int        Return PIN of this SavingsAccount.        '''        return self._pin    def deposit(self, amount):        '''(int) -> int        Deposit the given amount and return the new balance.        '''        self._balance += amount        return self._balance    def withdraw(self, amount):        '''(int) -> str or NoneType        Withdraw the given amount. Return None if successful,        or an error message if unsuccessful.        '''        if amount < 0:            return 'Amount must be >= 0'        elif self._balance < amount:            return 'Insufficient funds'        else:            self._balance -= amount            return None    def compute_interest(self):        '''() -> int        Compute, deposit, and return the interest.        '''        interest = self._balance * SavingsAccount.RATE        self.deposit(interest)        return interest",day1.bank.py,12